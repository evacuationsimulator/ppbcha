{"version":3,"sources":["webpack:///./packages/terriajs/lib/ReactViews/Map/Navigation/augmented_virtuality_tool.scss","webpack:///./packages/terriajs/lib/Models/AugmentedVirtuality.js","webpack:///./packages/terriajs/lib/ReactViews/Map/Navigation/AugmentedVirtualityTool.jsx"],"names":["module","exports","btn","btn-primary","btnPrimary","btn-blink","btnBlink","btn-primary--hover","btnPrimaryHover","blinker","toolButton","augmentedVirtualityTool","_defined","_interopRequireDefault","__webpack_require__","_defaultValue","_knockout","_Math","_Matrix","_Cartesian","_EllipsoidTerrainProvider","_sampleTerrainMostDetailed","obj","__esModule","default","AugmentedVirtuality","terria","that","this","_terria","_eventLoopState","_manualAlignment","_maximumUpdatesPerSecond","DEFAULT_MAXIMUM_UPDATES_PER_SECOND","_orientationUpdated","_alpha","_beta","_gamma","_realignAlpha","_realignHeading","_hoverLevel","PRESET_HEIGHTS","length","window","addEventListener","event","_storeOrientation","track","defineProperty","get","_eventLoopRunning","set","enable","resetAlignment","enabled","_startEventLoop","_getManualAlignment","startEnd","_setManualAlignment","maximumUpdatesPerSecond","MINIMUM_HOVER_HEIGHT","prototype","toggleEnabled","toggleManualAlignment","manualAlignment","toggleHoverHeight","hover","height","position","flyTo","cesium","viewer","camera","positionCartographic","clone","scene","terrainProvider","flyToHeight","then","updatedPosition","surfaceHeight","newPosition","fromRadians","longitude","latitude","pose","_getCurrentOrientation","destination","setView","currentViewer","notifyRepaintRequired","moveTo","maximumHeight","cameraPosition","viewerHeight","moveToLocation","undefined","hoverHeight","toDegrees","heading","intervalId","intervalMs","id","setInterval","_updateOrientation","clearInterval","alpha","beta","gamma","screenOrientation","_getCurrentScreenOrientation","_lastScreenOrientation","realignAlpha","realignHeading","_computeTerriaOrientation","rotationIncrement","rotation","IDENTITY","fromRotationZ","toRadians","multiply","fromRotationX","fromRotationY","r10","COLUMN1ROW0","r11","COLUMN1ROW1","r02","COLUMN0ROW2","r12","COLUMN1ROW2","r22","COLUMN2ROW2","Math","atan2","roll","pitch","sqrt","orientation","screen","angle","_react","_createReactClass","_propTypes","_ObserveModelMixin","_augmented_virtuality_tool","_Icon","_ViewerMode","_AugmentedVirtuality","AugmentedVirtualityTool","displayName","mixins","propTypes","object","isRequired","viewState","experimentalWarning","bool","getInitialState","augmentedVirtuality","props","experimentalWarningShown","realignHelpShown","resetRealignHelpShown","handleClickAVTool","state","setState","notifications","push","title","message","confirmText","handleClickRealign","handleClickResetRealign","handleClickHover","render","toggleImage","GLYPHS","arOff","toggleStyle","arOn","realignment","realignmentStyle","hoverLevel","hoverImage","arHover0","arHover1","arHover2","viewerMode","Leaflet","createElement","className","type","onClick","glyph","key","manualAlignmentSet","arRealign","arResetAlignment"],"mappings":"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","file":"1.TerriaMap.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"btn\":\"tjs-augmented_virtuality_tool__btn tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-primary\":\"tjs-augmented_virtuality_tool__btn-primary tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btnPrimary\":\"tjs-augmented_virtuality_tool__btn-primary tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-blink\":\"tjs-augmented_virtuality_tool__btn-blink tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btnBlink\":\"tjs-augmented_virtuality_tool__btn-blink tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-primary--hover\":\"tjs-augmented_virtuality_tool__btn-primary--hover\",\"btnPrimaryHover\":\"tjs-augmented_virtuality_tool__btn-primary--hover\",\"blinker\":\"tjs-augmented_virtuality_tool__blinker\",\"toolButton\":\"tjs-augmented_virtuality_tool__toolButton\",\"augmentedVirtualityTool\":\"tjs-augmented_virtuality_tool__augmentedVirtualityTool tjs-tool_button__toolButton\"};","\"use strict\";\n\nvar _defined = _interopRequireDefault(require(\"terriajs-cesium/Source/Core/defined\"));\n\nvar _defaultValue = _interopRequireDefault(require(\"terriajs-cesium/Source/Core/defaultValue\"));\n\nvar _knockout = _interopRequireDefault(require(\"terriajs-cesium/Source/ThirdParty/knockout\"));\n\nvar _Math = _interopRequireDefault(require(\"terriajs-cesium/Source/Core/Math.js\"));\n\nvar _Matrix = _interopRequireDefault(require(\"terriajs-cesium/Source/Core/Matrix3.js\"));\n\nvar _Cartesian = _interopRequireDefault(require(\"terriajs-cesium/Source/Core/Cartesian3.js\"));\n\nvar _EllipsoidTerrainProvider = _interopRequireDefault(require(\"terriajs-cesium/Source/Core/EllipsoidTerrainProvider\"));\n\nvar _sampleTerrainMostDetailed = _interopRequireDefault(require(\"terriajs-cesium/Source/Core/sampleTerrainMostDetailed\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Manages state for Augmented Virtuality mode.\n *\n * This mode uses the devices orientation sensors to change the viewers viewport to match the change in orientation.\n *\n * Term Augmented Virtuality:\n * \"The use of real-world sensor information (e.g., gyroscopes) to control a virtual environment is an additional form\n * of augmented virtuality, in which external inputs provide context for the virtual view.\"\n * {@link https://en.wikipedia.org/wiki/Mixed_reality}\n *\n * @alias AugmentedVirtuality\n * @constructor\n */\nvar AugmentedVirtuality = function AugmentedVirtuality(terria) {\n  var that = this;\n  this._terria = terria; // Note: We create a persistant object and define a transient property, since knockout needs a persistant variable\n  //       to track, but for state we want a 'maybe' intervalId.\n\n  this._eventLoopState = {};\n  this._manualAlignment = false;\n  this._maximumUpdatesPerSecond = AugmentedVirtuality.DEFAULT_MAXIMUM_UPDATES_PER_SECOND;\n  this._orientationUpdated = false;\n  this._alpha = 0;\n  this._beta = 0;\n  this._gamma = 0;\n  this._realignAlpha = 0;\n  this._realignHeading = 0; // Set the default height to be the last height so that when we first toggle (and increment) we cycle and go to the first height.\n\n  this._hoverLevel = AugmentedVirtuality.PRESET_HEIGHTS.length - 1; // Always run the device orientation event, this way as soon as we enable we know where we are and set the\n  // orientation rather then having to wait for the next update.\n  // The following is disabled because chrome does not currently support deviceorientationabsolute correctly:\n  // if ('ondeviceorientationabsolute' in window)\n  // {\n  //     window.addEventListener('deviceorientationabsolute', function(event) {that._orientationUpdate(event);} );\n  // }\n  // else\n\n  if (\"ondeviceorientation\" in window) {\n    window.addEventListener(\"deviceorientation\", function (event) {\n      that._storeOrientation(event);\n    });\n  } // Make the variables used by the object properties knockout observable so that changes in the state notify the UI\n  // and cause a UI update. Note: These are all of the variables used just by the getters (not the setters), since\n  // these unqiquely define what the current state is and are the only things that can effect/cause the state to change\n  // (note: _eventLoopState is hidden behind ._eventLoopRunning() ).\n\n\n  _knockout[\"default\"].track(this, [\"_eventLoopState\", \"_manualAlignment\", \"_maximumUpdatesPerSecond\", \"_realignAlpha\", \"_realignHeading\", \"_hoverLevel\"]); // Note: The following properties are defined as knockout properties so that they can be used to trigger updates on the UI.\n\n  /**\n   * Gets or sets whether Augmented Virtuality mode is currently enabled (true) or not (false).\n   *\n   * Note: If {@link AugmentedVirtuality#manualAlignment} is enabled and the state is changed it will be disabled.\n   *\n   * @memberOf AugmentedVirtuality.prototype\n   * @member {Boolean} enabled\n   */\n\n\n  _knockout[\"default\"].defineProperty(this, \"enabled\", {\n    get: function get() {\n      return this._eventLoopRunning() || this._manualAlignment;\n    },\n    set: function set(enable) {\n      if (enable !== true) {\n        enable = false;\n        this.resetAlignment();\n      }\n\n      if (enable !== this.enabled) {\n        // If we are changing the enabled state then disable manual alignment.\n        // We only do this if we are changing the enabled state so that the client can repeatedly call the\n        // setting without having any effect if they aren't changing the enabled state, but so that every time\n        // that the state is changed that the manual alignment is turned back off initally.\n        this._manualAlignment = false;\n\n        this._startEventLoop(enable);\n      }\n    }\n  });\n  /**\n   * Gets or sets whether manual realignment mode is currently enabled (true) or not (false).\n   *\n   * @memberOf AugmentedVirtuality.prototype\n   * @member {Boolean} manualAlignment\n   */\n\n\n  _knockout[\"default\"].defineProperty(this, \"manualAlignment\", {\n    get: function get() {\n      return this._getManualAlignment();\n    },\n    set: function set(startEnd) {\n      this._setManualAlignment(startEnd);\n    }\n  });\n  /**\n   * Gets whether a manual realignment has been specified (true) or not (false).\n   *\n   * @memberOf AugmentedVirtuality.prototype\n   * @member {Boolean} manualAlignmentSet\n   */\n\n\n  _knockout[\"default\"].defineProperty(this, \"manualAlignmentSet\", {\n    get: function get() {\n      return this._realignAlpha !== 0.0 || this._realignHeading !== 0.0;\n    }\n  });\n  /**\n   * Gets the index of the current hover level.\n   *\n   * Use <code>AugmentedVirtuality.PRESET_HEIGHTS.length</code> to find the total avaliable levels.\n   *\n   * @memberOf AugmentedVirtuality.prototype\n   * @member {int} hoverLevel\n   */\n\n\n  _knockout[\"default\"].defineProperty(this, \"hoverLevel\", {\n    get: function get() {\n      return this._hoverLevel;\n    }\n  });\n  /**\n   * Gets or sets the the maximum number of times that the camera orientation will be updated per second. This is\n   * the number of camera orientation updates per seconds is capped to (explicitly the number of times the\n   * orientation is updated per second might be less but it won't be more then this number). We want the number of\n   * times that the orientation is updated capped so that we don't consume to much battery life updating to\n   * frequently, but responsiveness is still acceptable.\n   *\n   * @memberOf AugmentedVirtuality.prototype\n   * @member {Float} maximumUpdatesPerSecond\n   */\n\n\n  _knockout[\"default\"].defineProperty(this, \"maximumUpdatesPerSecond\", {\n    get: function get() {\n      return this._maximumUpdatesPerSecond;\n    },\n    set: function set(maximumUpdatesPerSecond) {\n      this._maximumUpdatesPerSecond = maximumUpdatesPerSecond; // If we are currently enabled reset to update the timing interval used.\n\n      if (this._eventLoopRunning()) {\n        this._startEventLoop(false);\n\n        this._startEventLoop(true);\n      }\n    }\n  });\n\n  this.enabled = false;\n};\n/**\n * Gets the the maximum number of times that the camera orientation will be updated per second by default. This is the\n * number of camera orientation updates per seconds is capped to by default (explicitly the number of times the\n * orientation is updated per second might be less but it won't be more then this number). We want the number of times\n * that the orientation is updated capped so that we don't consume to much battery life updating to frequently, but\n * responsiveness is still acceptable.\n */\n\n\nAugmentedVirtuality.DEFAULT_MAXIMUM_UPDATES_PER_SECOND = 10.0;\n/**\n * The minimum height that the viewer is allowed to hover at.\n */\n\nAugmentedVirtuality.MINIMUM_HOVER_HEIGHT = 20.0;\n/* These are the heights that we can toggle through (in meters - above the surface height).\n */\n\nAugmentedVirtuality.PRESET_HEIGHTS = [1000, 250, 20];\n/**\n * Toggles whether the AugmentedVirutuality mode is enabled or disabled.\n */\n\nAugmentedVirtuality.prototype.toggleEnabled = function () {\n  this.enabled = !this.enabled;\n};\n/**\n * Toggles whether manual alignement is enabled or disabled.\n */\n\n\nAugmentedVirtuality.prototype.toggleManualAlignment = function () {\n  this.manualAlignment = !this.manualAlignment;\n};\n/**\n * Resets the alignment so that the alignement matches the devices absolute alignment.\n */\n\n\nAugmentedVirtuality.prototype.resetAlignment = function () {\n  this._orientationUpdated = true;\n  this._realignAlpha = 0;\n  this._realignHeading = 0;\n};\n/**\n * Toggles the viewer between a range of predefined heights, setting the cameras orientation so that it matches the\n * correct orientation.\n */\n\n\nAugmentedVirtuality.prototype.toggleHoverHeight = function () {\n  this._hoverLevel = (this._hoverLevel + 1) % AugmentedVirtuality.PRESET_HEIGHTS.length;\n  this.hover(AugmentedVirtuality.PRESET_HEIGHTS[this._hoverLevel]);\n};\n/**\n * Moves the viewer to a specified height, setting the orientation so that it matches the correct Augmented Virtuality\n * orientation.\n *\n * @param {Float} height The height in Meters above the globe surface. Note: If height is below\n *                       {@link AugmentedVirtuality.MINIMUM_HOVER_HEIGHT} the height will be set to\n *                       {@link AugmentedVirtuality.MINIMUM_HOVER_HEIGHT} to avoid visual artifacts when the viewer\n *                       becomes to close to the surface.\n * @param {Cartographic} [position] The location to hover over. If not specified the current camera location will be used.\n * @param {Boolean} [flyTo=true] Whether to fly to the location (true) or whether to jump to the location (false).\n */\n\n\nAugmentedVirtuality.prototype.hover = function (height, position, flyTo) {\n  var that = this; // Get access to the camera...if it is not avaliable we can't set the new height so just return now.\n\n  if (!(0, _defined[\"default\"])(this._terria.cesium) || !(0, _defined[\"default\"])(this._terria.cesium.viewer) || !(0, _defined[\"default\"])(this._terria.cesium.viewer.camera)) {\n    return;\n  }\n\n  var camera = this._terria.cesium.viewer.camera;\n\n  if (!(0, _defined[\"default\"])(position)) {\n    position = camera.positionCartographic.clone();\n  }\n\n  flyTo = (0, _defaultValue[\"default\"])(flyTo, true); // Clamp the minimum hover height (heights below this value could lead to poor visual artifacts).\n\n  if (height < AugmentedVirtuality.MINIMUM_HOVER_HEIGHT) {\n    height = AugmentedVirtuality.MINIMUM_HOVER_HEIGHT;\n  } // Reset the viewer height.\n\n\n  function flyToHeight(surfaceHeight) {\n    if ((0, _defined[\"default\"])(surfaceHeight)) {\n      height += surfaceHeight;\n    }\n\n    var newPosition = _Cartesian[\"default\"].fromRadians(position.longitude, position.latitude, height);\n\n    var pose = that._getCurrentOrientation();\n\n    pose.destination = newPosition;\n\n    if (flyTo) {\n      camera.flyTo(pose);\n    } else {\n      camera.setView(pose);\n    } // Needed on mobile to make sure that the render is marked as dirty so that once AV mode has been disabled for a\n    // while and then is reenabled the .setView() function still has effect (otherwise dispite the call the .setView()\n    // the view orientation does not visually update until the user manualy moves the camera position).\n\n\n    that._terria.currentViewer.notifyRepaintRequired();\n  } // Get the ground surface height at this location and offset the height by it.\n\n\n  if (!(0, _defined[\"default\"])(this._terria.cesium) || !(0, _defined[\"default\"])(this._terria.cesium.scene) || !(0, _defined[\"default\"])(this._terria.cesium.scene.terrainProvider) || this._terria.cesium.scene.terrainProvider instanceof _EllipsoidTerrainProvider[\"default\"]) {\n    // If we can't get access to the terrain provider or we can get access to the terrain provider and the provider is just the Ellipsoid then use the height of 0.\n    flyToHeight(0);\n  } else {\n    var terrainProvider = this._terria.cesium.scene.terrainProvider;\n    (0, _sampleTerrainMostDetailed[\"default\"])(terrainProvider, [position]).then(function (updatedPosition) {\n      flyToHeight(updatedPosition[0].height);\n    });\n  }\n};\n/**\n * Moves the viewer to a specified location while maintaining the current height and the correct Augmented Virtuality\n * orientation.\n *\n * @param {Cartographic} position The location to hover move to.\n * @param {Float} [maximumHeight] The maximum height (in meters) to cap the current camera height to (if this value is\n *                                specified and the viewer is above this height the camera will be restricted to this height).\n * @param {Boolean} [flyTo] Whether to fly to the location (true) or whether to jump to the location (false).\n *\n * When the manual alignment is enabled this function has no effect.\n */\n\n\nAugmentedVirtuality.prototype.moveTo = function (position, maximumHeight, flyTo) {\n  var that = this; // If we are in manual alignment mode we don't allow the viewer to move (since this would create a jaring UX for most use cases).\n\n  if (this._manualAlignment) {\n    return;\n  } // Get access to the camera...if it is not avaliable we can't get the current height (or set the new location) so just return now.\n\n\n  if (!(0, _defined[\"default\"])(this._terria.cesium) || !(0, _defined[\"default\"])(this._terria.cesium.viewer) || !(0, _defined[\"default\"])(this._terria.cesium.viewer.camera)) {\n    return;\n  }\n\n  var camera = this._terria.cesium.viewer.camera;\n  var cameraPosition = camera.positionCartographic.clone();\n  var viewerHeight = cameraPosition.height; // Reset the viewer height.\n\n  function moveToLocation(surfaceHeight) {\n    if (!(0, _defined[\"default\"])(surfaceHeight)) {\n      surfaceHeight = 0;\n    }\n\n    var hoverHeight = viewerHeight - surfaceHeight;\n\n    if ((0, _defined[\"default\"])(maximumHeight) && hoverHeight > maximumHeight) {\n      hoverHeight = maximumHeight;\n    }\n\n    that.hover(hoverHeight, position, flyTo);\n  } // Get the ground surface height at this location and offset the height by it.\n\n\n  if (!(0, _defined[\"default\"])(this._terria.cesium) || !(0, _defined[\"default\"])(this._terria.cesium.scene) || !(0, _defined[\"default\"])(this._terria.cesium.scene.terrainProvider) || this._terria.cesium.scene.terrainProvider instanceof _EllipsoidTerrainProvider[\"default\"]) {\n    // If we can't get access to the terrain provider or we can get access to the terrain provider and the provider is just the Ellipsoid then use the height of 0.\n    moveToLocation(undefined);\n  } else {\n    var terrainProvider = this._terria.cesium.scene.terrainProvider;\n    (0, _sampleTerrainMostDetailed[\"default\"])(terrainProvider, [cameraPosition]).then(function (updatedPosition) {\n      moveToLocation(updatedPosition[0].height);\n    });\n  }\n};\n/**\n * Whether the user is currently setting a manual alignment.\n *\n * See also {@link AugmentedVirtuality#_setManualAlignment}.\n *\n * @return {Boolean} Whether the user is currently setting a manual alignment (true) or not (false).\n * @private\n */\n\n\nAugmentedVirtuality.prototype._getManualAlignment = function () {\n  return this.enabled && this._manualAlignment;\n};\n/**\n * Starts / stops manual alignment.\n *\n * When manual realignment is enabled it allows the user to specify a new origin for the alignment between the devices\n * physical and virtual alignment. When manual alignment is enabled the orientation is locked, to allow the user to\n * realign a visual landmark with a physical landmark.\n *\n * Note: Manual alignment is only done for the heading axis, this is because in practice we have found that the heading\n * axis is often out as mobile devices seem to have difficulty obtaining the compass direction, but seem to perform\n * relatively well in the other axes.\n *\n * Note: Realignment is only possible when AugmentedVirtuality is enabled. If AugmentedVirtuality is disabled while\n *       manual alignment is in progress it will be cancelled.\n *\n * See also {@link AugmentedVirtuality#_getManualAlignment}.\n *\n * @param {Boolean} startEnd Whether the user is starting (true) or ending (false) the realignment.\n * @private\n */\n\n\nAugmentedVirtuality.prototype._setManualAlignment = function (startEnd) {\n  // Only allow manual alignment changes when the module is enabled.\n  if (this.enabled !== true) {\n    return;\n  } // Sanitise the input value to a boolean.\n\n\n  if (startEnd !== true) {\n    startEnd = false;\n  }\n\n  if (startEnd === false && (0, _defined[\"default\"])(this._terria.cesium) && (0, _defined[\"default\"])(this._terria.cesium.viewer) && (0, _defined[\"default\"])(this._terria.cesium.viewer.camera)) {\n    this._realignAlpha = this._alpha;\n    this._realignHeading = _Math[\"default\"].toDegrees(this._terria.cesium.viewer.camera.heading);\n  }\n\n  if (this._manualAlignment !== startEnd) {\n    this._manualAlignment = startEnd;\n\n    this._startEventLoop(!this._manualAlignment);\n  }\n};\n/**\n * Whether the event loop is currently running.\n *\n * @return {Boolean} enable Whether to start the event loop is currently running (true) or not (false).\n * @private\n */\n\n\nAugmentedVirtuality.prototype._eventLoopRunning = function () {\n  return (0, _defined[\"default\"])(this._eventLoopState.intervalId);\n};\n/**\n * Start or stop the Augmented Virutuality mode event loop. When enabled the orientation will effect the cameras\n * view and when disabled the device orientation will not effect the cameras view.\n *\n * @param {Boolean} enable Whether to start the event loop (true) or stop the event loop (false).\n * @private\n */\n\n\nAugmentedVirtuality.prototype._startEventLoop = function (enable) {\n  // Are we actually changing the state?\n  if (this._eventLoopRunning() !== enable) {\n    if (enable === true) {\n      var that = this;\n      this._orientationUpdated = true;\n      var intervalMs = 1000 / this._maximumUpdatesPerSecond;\n      var id = setInterval(function () {\n        that._updateOrientation();\n      }, intervalMs);\n      this._eventLoopState = {\n        intervalId: id\n      };\n    } else {\n      clearInterval(this._eventLoopState.intervalId);\n      this._eventLoopState = {};\n    }\n  }\n};\n/**\n * Device orientation update event callback function. Stores the updated orientation into the object state.\n *\n * @param {Object} event Contains the updated device orientation (in .alpha, .beta, .gamma).\n * @private\n */\n\n\nAugmentedVirtuality.prototype._storeOrientation = function (event) {\n  this._alpha = event.alpha;\n  this._beta = event.beta;\n  this._gamma = event.gamma;\n  this._orientationUpdated = true;\n};\n/**\n * This function updates the cameras orientation using the last orientation recorded and the current screen orientation.\n *\n * @private\n */\n\n\nAugmentedVirtuality.prototype._updateOrientation = function () {\n  // Check if the screen orientation has changed and mark the orientation updated if it has.\n  var screenOrientation = this._getCurrentScreenOrientation();\n\n  if (screenOrientation !== this._lastScreenOrientation) {\n    this._orientationUpdated = true;\n  }\n\n  this._lastScreenOrientation = screenOrientation; // Optomise by only updating the camera view if some part of the orientation calculation has changed.\n\n  if (!this._orientationUpdated) {\n    // The orientation has not been updated so don't waste time changing the orientation.\n    return;\n  }\n\n  this._orientationUpdated = false; // Get access to the camera...if it is not avaliable we can't set the orientation so just return now.\n\n  if (!(0, _defined[\"default\"])(this._terria.cesium) || !(0, _defined[\"default\"])(this._terria.cesium.viewer) || !(0, _defined[\"default\"])(this._terria.cesium.viewer.camera)) {\n    return;\n  }\n\n  var camera = this._terria.cesium.viewer.camera;\n  camera.setView(this._getCurrentOrientation(screenOrientation)); // Needed on mobile to make sure that the render is marked as dirty so that once AV mode has been disabled for a\n  // while and then is reenabled the .setView() function still has effect (otherwise dispite the call the .setView()\n  // the view orientation does not visually update until the user manualy moves the camera position).\n\n  this._terria.currentViewer.notifyRepaintRequired();\n};\n/**\n * Gets the current orientation stored in the object state and returns the roll, pitch and heading which can be used to set the cameras orientation.\n *\n * @param {Float} screenOrientation The screen orientation in degrees. Note: This field is optional, if supplied this value will be used for the screen orientation, otherwise the screen orientation will be obtained during the execution of this function.\n * @return {Object} A object with the roll, pitch and heading stored into the orientation.\n * @private\n */\n\n\nAugmentedVirtuality.prototype._getCurrentOrientation = function (screenOrientation) {\n  var alpha = this._alpha;\n  var beta = this._beta;\n  var gamma = this._gamma;\n  var realignAlpha = this._realignAlpha;\n  var realignHeading = this._realignHeading;\n\n  if (!(0, _defined[\"default\"])(screenOrientation)) {\n    screenOrientation = this._getCurrentScreenOrientation();\n  }\n\n  return this._computeTerriaOrientation(alpha, beta, gamma, screenOrientation, realignAlpha, realignHeading);\n};\n/**\n * Turns the orientation in the device frame of reference into an orientation suitable for specifying the Terria camera orientation.\n *\n * @param {Float} alpha The alpha value of the device orientation in degrees (this is the alpha value in the device's frame of reference).\n * @param {Float} beta  The beta  value of the device orientation in degrees (this is the beta  value in the device's frame of reference).\n * @param {Float} gamma The gamma value of the device orientation in degrees (this is the gamma value in the device's frame of reference).\n * @param {Float} screenOrientation The screen orientation in degrees.\n * @param {Float} realignAlpha   The value of the alpha   value the last time realignment was completed (supply zero if realignment is not supported).\n * @param {Float} realignHeading The value of the heading value the last time realignment was completed (supply zero if realignment is not supported).\n * @return {Object} An object with the roll, pitch and heading stored into the orientation.\n * @private\n */\n\n\nAugmentedVirtuality.prototype._computeTerriaOrientation = function (alpha, beta, gamma, screenOrientation, realignAlpha, realignHeading) {\n  // Note: The algorithmic formulation in this function is for simplicity of mathematical expression, readability,\n  //       maintainability and modification (i.e. it is easy to understand how to update or insert new offsets or features).\n  //       This is not the simplest form which clearly flows from the current formuleation and clearly simplify the\n  //       logic and operations but would increase the cost of future modifications and reduce the readability of the\n  //       expression. It is not anticipated that the current verbose implementation would have a significant impact\n  //       on performance or accuracy, but obviously there will be some impact on both and it can be simplified in\n  //       future if needed.\n  var rotation = _Matrix[\"default\"].clone(_Matrix[\"default\"].IDENTITY, rotation);\n\n  var rotationIncrement; // Roll - Counteract the change in the (orientation) frame of reference when the screen is rotated and the\n  //        rotation lock is not on (the browser reorients the frame of reference to align with the new screen\n  //        orientation - where as we want it of the device relative to the world).\n\n  rotationIncrement = _Matrix[\"default\"].fromRotationZ(_Math[\"default\"].toRadians(screenOrientation));\n\n  _Matrix[\"default\"].multiply(rotation, rotationIncrement, rotation); // Pitch - Align the device orientation frame with the ceasium orientation frame.\n\n\n  rotationIncrement = _Matrix[\"default\"].fromRotationX(_Math[\"default\"].toRadians(90));\n\n  _Matrix[\"default\"].multiply(rotation, rotationIncrement, rotation); // Roll - Apply the deivce roll.\n\n\n  rotationIncrement = _Matrix[\"default\"].fromRotationZ(_Math[\"default\"].toRadians(gamma));\n\n  _Matrix[\"default\"].multiply(rotation, rotationIncrement, rotation); // Pitch - Apply the deivce pitch.\n\n\n  rotationIncrement = _Matrix[\"default\"].fromRotationX(_Math[\"default\"].toRadians(-beta));\n\n  _Matrix[\"default\"].multiply(rotation, rotationIncrement, rotation); // Heading - Apply the incremental deivce heading (from when start was last triggered).\n\n\n  rotationIncrement = _Matrix[\"default\"].fromRotationY(_Math[\"default\"].toRadians(-(alpha - realignAlpha)));\n\n  _Matrix[\"default\"].multiply(rotation, rotationIncrement, rotation); // Heading - Use the offset when the orientation was last started.\n  //           Note: This is logically different from the alpha value and can only be applied here in the same way\n  //                 since Cesium camera is RPH (Heading last - most local). See Cesium camera rotation decomposition\n  //                 for more information on the Cesium camera formuleation.\n\n\n  rotationIncrement = _Matrix[\"default\"].fromRotationY(_Math[\"default\"].toRadians(realignHeading));\n\n  _Matrix[\"default\"].multiply(rotation, rotationIncrement, rotation); // Decompose rotation matrix into roll, pitch and heading to supply to Cesium camera.\n  //\n  // Use notation:\n  //     R = Roll, P = Pitch, H = Heading\n  //     SH = Sin(Heading), CH = Cos(Heading)\n  //\n  // Ceasium camera rotation = RPH:\n  //     [ CR, -SR,   0][  1,   0,   0][ CH,   0,  SH]   [CRCH-SRSPSH, -SRCP, CRSH-SRSPCH]\n  //     [ SR,  CR,   0][  0,  CP,  SP][  0,   1,   0] = [SRCH-CRSPSH,  CRCP, SRSH+CRSPCH]\n  //     [  0,   0,   1][  0, -SP,  CP][-SH,   0,  CH]   [   -CPSH   ,   -SP,    CPCH    ]\n  //     Note: The sign difference of the Sin terms in pitch is different to the standard right handed rotation since\n  //           Cesium rotates pitch in the left handed direction. Both heading and roll are right handed rotations.\n  //\n  // Use the following notation to refer to elements in the Cesium camera rotation matrix:\n  //     [R00, R10, R20]\n  //     [R01, R11, R21]\n  //     [R02, R12, R22]\n  //\n  // Also note: Tan(X) = Sin(X) / Cos(X)\n  //\n  // Decompose matrix:\n  //    H = ATan(Tan(H)) = ATan(Sin(H)/Cos(H)) = ATan (SH / CH) = ATan(CPSH/CPCH) = ATan (-R02 / R22)\n  //    R = ATan(Tan(R)) = ATan(Sin(R)/Cos(R)) = ATan (SR / CR) = ATan(SRCP/CRCP) = ATan (-R10 / R11)\n  //    P = ATan(Tan(P)) = ATan(Sin(P)/Cos(P)) = ATan (SP / CP)\n  //                                             SP = -R12\n  //                                             Need to find CP:\n  //                                                 CP = Sqrt(CP^2)\n  //                                                    = Sqrt(CP^2*(CH^2+SH^2))              Since: (Cos@^2 + Sin@^2) = 1\n  //                                                    = Sqrt((CP^2)*(CH^2) + (CP^2)*(SH^2)) Expand\n  //                                                    = Sqrt((CPCH)^2 + (CPSH)^2)           Since: N^2*M^2 = (NM)^2\n  //                                                    = Sqrt(R22^2 + (-R02)^2)              Substitute\n  //                                                    = Sqrt(R22^2 + R02^2)                 Since: (-N)^2 = N^2\n  //  So P = ATan (-R12 / Sqrt(R22^2 + R02^2))\n  // Simplify notation for readability:\n\n\n  var r10 = rotation[_Matrix[\"default\"].COLUMN1ROW0];\n  var r11 = rotation[_Matrix[\"default\"].COLUMN1ROW1];\n  var r02 = rotation[_Matrix[\"default\"].COLUMN0ROW2];\n  var r12 = rotation[_Matrix[\"default\"].COLUMN1ROW2];\n  var r22 = rotation[_Matrix[\"default\"].COLUMN2ROW2];\n\n  var heading = _Math[\"default\"].toDegrees(Math.atan2(-r02, r22));\n\n  var roll = _Math[\"default\"].toDegrees(Math.atan2(-r10, r11));\n\n  var pitch = _Math[\"default\"].toDegrees(Math.atan2(-r12, Math.sqrt(r02 * r02 + r22 * r22))); // Create an object with the roll, pitch and heading we just computed.\n\n\n  return {\n    orientation: {\n      roll: _Math[\"default\"].toRadians(roll),\n      pitch: _Math[\"default\"].toRadians(pitch),\n      heading: _Math[\"default\"].toRadians(heading)\n    }\n  };\n};\n/**\n * Gets the current screen orientation.\n *\n * @return {Object} The current screen orientation in degrees.\n * @private\n */\n\n\nAugmentedVirtuality.prototype._getCurrentScreenOrientation = function () {\n  if ((0, _defined[\"default\"])(screen.orientation) && (0, _defined[\"default\"])(screen.orientation.angle)) {\n    return screen.orientation.angle;\n  }\n\n  if ((0, _defined[\"default\"])(window.orientation)) {\n    return window.orientation;\n  }\n\n  return 0;\n};\n\nmodule.exports = AugmentedVirtuality;","\"use strict\";\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _createReactClass = _interopRequireDefault(require(\"create-react-class\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _ObserveModelMixin = _interopRequireDefault(require(\"../../ObserveModelMixin\"));\n\nvar _augmented_virtuality_tool = _interopRequireDefault(require(\"./augmented_virtuality_tool.scss\"));\n\nvar _Icon = _interopRequireDefault(require(\"../../Icon\"));\n\nvar _ViewerMode = _interopRequireDefault(require(\"../../../Models/ViewerMode\"));\n\nvar _defined = _interopRequireDefault(require(\"terriajs-cesium/Source/Core/defined\"));\n\nvar _AugmentedVirtuality = _interopRequireDefault(require(\"../../../Models/AugmentedVirtuality\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar AugmentedVirtualityTool = (0, _createReactClass[\"default\"])({\n  displayName: \"AugmentedVirtualityTool\",\n  mixins: [_ObserveModelMixin[\"default\"]],\n  propTypes: {\n    terria: _propTypes[\"default\"].object.isRequired,\n    viewState: _propTypes[\"default\"].object.isRequired,\n    experimentalWarning: _propTypes[\"default\"].bool\n  },\n  getInitialState: function getInitialState() {\n    return {\n      augmentedVirtuality: new _AugmentedVirtuality[\"default\"](this.props.terria),\n      experimentalWarningShown: false,\n      realignHelpShown: false,\n      resetRealignHelpShown: false\n    };\n  },\n  handleClickAVTool: function handleClickAVTool() {\n    // Make the AugmentedVirtuality module avaliable elsewhere.\n    this.props.terria.augmentedVirtuality = this.state.augmentedVirtuality;\n\n    if ((0, _defined[\"default\"])(this.props.experimentalWarning) && this.props.experimentalWarning !== false && !this.state.experimentalWarningShown) {\n      this.setState({\n        experimentalWarningShown: true\n      });\n      this.props.viewState.notifications.push({\n        title: \"Experimental Feature: Augmented Reality\",\n        message: \"Augmented Reality mode is currently in beta. \" + \"This mode is only designed for use on the latest high end mobile devices. \" + \"<br /><br />WARNING: This mode can consume a lot of data, please be mindful of data usage charges from your network provider. \" + \"<br /><br />The accuracy of this mode depends on the accuracy of your mobile devices internal compass.\",\n        confirmText: \"Got it\"\n      });\n    }\n\n    this.state.augmentedVirtuality.toggleEnabled();\n  },\n  handleClickRealign: function handleClickRealign() {\n    if (!this.state.realignHelpShown) {\n      this.setState({\n        realignHelpShown: true\n      });\n      this.props.viewState.notifications.push({\n        title: \"Manual Alignment\",\n        message: \"Align your mobile device so that it corresponds with the maps current alignment, then click the blinking compass.\" + \" If no landmarks to align with are currently visible on the map, you can move the map using\" + \" drag and pinch actions until a recognisable landmark is visible before aligning the device with the map.\" + '<br /><div><img width=\"100%\" src=\"./build/TerriaJS/images/ar-realign-guide.gif\" /></div>' + \"<br />Tip: The sun or moon are often good landmarks to align with if you are in a location you aren\\x27t familiar with (be careful not to look at the sun - it can hurt your eyes).\",\n        confirmText: \"Got it\"\n      });\n    }\n\n    this.state.augmentedVirtuality.toggleManualAlignment();\n  },\n  handleClickResetRealign: function handleClickResetRealign() {\n    if (!this.state.resetRealignHelpShown) {\n      this.setState({\n        resetRealignHelpShown: true\n      });\n      this.props.viewState.notifications.push({\n        title: \"Reset Alignment\",\n        message: \"Resetting to compass alignment. If the alignment doesn\\x27t match the real world try waving\" + \" your device in a figure 8 motion to recalibrate device. This can be done at any time.\" + \"<br /> <br />Avoid locations with magnetic fields or metal objects as these may disorient the devices compass.\",\n        confirmText: \"Got it\"\n      });\n    }\n\n    this.state.augmentedVirtuality.resetAlignment();\n  },\n  handleClickHover: function handleClickHover() {\n    this.state.augmentedVirtuality.toggleHoverHeight();\n  },\n  render: function render() {\n    var enabled = this.state.augmentedVirtuality.enabled;\n    var toggleImage = _Icon[\"default\"].GLYPHS.arOff;\n    var toggleStyle = _augmented_virtuality_tool[\"default\"].btn;\n\n    if (enabled) {\n      toggleImage = _Icon[\"default\"].GLYPHS.arOn;\n      toggleStyle = _augmented_virtuality_tool[\"default\"].btnPrimary;\n    }\n\n    var realignment = this.state.augmentedVirtuality.manualAlignment;\n    var realignmentStyle = _augmented_virtuality_tool[\"default\"].btn;\n\n    if (realignment) {\n      realignmentStyle = _augmented_virtuality_tool[\"default\"].btnBlink;\n    }\n\n    var hoverLevel = this.state.augmentedVirtuality.hoverLevel;\n    var hoverImage = _Icon[\"default\"].GLYPHS.arHover0; // Note: We use the image of the next level that we will be changing to, not the level the we are currently at.\n\n    switch (hoverLevel) {\n      case 0:\n        hoverImage = _Icon[\"default\"].GLYPHS.arHover0;\n        break;\n\n      case 1:\n        hoverImage = _Icon[\"default\"].GLYPHS.arHover1;\n        break;\n\n      case 2:\n        hoverImage = _Icon[\"default\"].GLYPHS.arHover2;\n        break;\n    }\n\n    return this.props.terria.viewerMode !== _ViewerMode[\"default\"].Leaflet ? _react[\"default\"].createElement(\"div\", {\n      className: _augmented_virtuality_tool[\"default\"].augmentedVirtualityTool\n    }, _react[\"default\"].createElement(\"button\", {\n      type: \"button\",\n      className: toggleStyle,\n      title: \"augmented reality tool\",\n      onClick: this.handleClickAVTool\n    }, _react[\"default\"].createElement(_Icon[\"default\"], {\n      glyph: toggleImage\n    })), enabled ? [_react[\"default\"].createElement(\"button\", {\n      type: \"button\",\n      className: _augmented_virtuality_tool[\"default\"].btn,\n      title: \"toggle hover height\",\n      onClick: this.handleClickHover,\n      key: \"0\"\n    }, _react[\"default\"].createElement(_Icon[\"default\"], {\n      glyph: hoverImage\n    })), !this.state.augmentedVirtuality.manualAlignmentSet ? _react[\"default\"].createElement(\"button\", {\n      type: \"button\",\n      className: realignmentStyle,\n      title: \"toggle manual alignment\",\n      onClick: this.handleClickRealign,\n      key: \"1\"\n    }, _react[\"default\"].createElement(_Icon[\"default\"], {\n      glyph: _Icon[\"default\"].GLYPHS.arRealign\n    })) : null, this.state.augmentedVirtuality.manualAlignmentSet && !realignment ? _react[\"default\"].createElement(\"button\", {\n      type: \"button\",\n      className: _augmented_virtuality_tool[\"default\"].btn,\n      title: \"reset compass alignment\",\n      onClick: this.handleClickResetRealign,\n      key: \"2\"\n    }, _react[\"default\"].createElement(_Icon[\"default\"], {\n      glyph: _Icon[\"default\"].GLYPHS.arResetAlignment\n    })) : null] : null) : null;\n  }\n});\nmodule.exports = AugmentedVirtualityTool;"],"sourceRoot":""}